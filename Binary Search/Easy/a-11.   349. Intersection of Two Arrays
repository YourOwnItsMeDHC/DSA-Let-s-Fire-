// //Refer Notes(15)
// //Intersection means, element which is same in both arrays, just return that //element (but it should not repeat that same element again in answer output)


// //Approach-1 : Binary Search :
// class Solution {
//     public int[] intersection(int[] nums1, int[] nums2) {
        
//         //For storing intersection elements :
//         Set<Integer> set = new HashSet<>();
        
//       //Sort nums2, so we can apply binary search to find intersection elements
//       //by comnparing it with elements of num1 :
//         Arrays.sort(nums2);
        
//         for(int elementOfNums1 : nums1) {
//             if(binarySearch(nums2, elementOfNums1)) {
//                 set.add(elementOfNums1);
//             }
//         }
        
//         //We have to return output in int[] format, so convert it :
//         int i=0;
//         int[] result = new int[set.size()];
//         for(int elementOfResult : set) {
//             result[i++] = elementOfResult;
//         }
        
//         //Now, just return the "result" array :
//         return result;
        
//     }
    
//     boolean binarySearch(int[] nums, int target) {
//         int start=0, end=nums.length-1;
//         while(start <= end) {
//             int mid = start + (end-start)/2;
            
//             if(nums[mid] < target) {
//                 start = mid+1;
//             }
//             else if(nums[mid] > target) {
//                 end = mid-1;
//             }
//             else {                           //nums[mid] == target
//                 return true;                 //Target found
//             }
//         }
//         return false;                        //Target not found
//     }
// }














//Approach-2 : Two-Pointers :
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        
        //For storing intersection elements :
        Set<Integer> set = new HashSet<>();
        
        //Sort both arrays, and point both pointers to same index in both arrays
        //So, they both pointer will find intersected element, linearly
        //by co-ordinating like a dost
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        
        int i=0;
        int j=0;
        
        while(i<nums1.length && j<nums2.length) {
            if(nums1[i] < nums2[j]) {
                i++;
            }
            else if(nums1[i] > nums2[j]) {
                j++;
            }
            else {                                    //nums1[i] == nums2[j]
                set.add(nums1[i]);                    //or set.add(nums2[j])
                
                //Now, Find next possible intersected element, saath saath like a                 //dost, so just do increment of i and j
                i++;
                j++;
            }
        }
        
        //Wwe have to return output in int[] format, so convert it :
        int index=0;
        int[] result = new int[set.size()];
        for(int elementOfResult : set) {
            result[index++] = elementOfResult;
        }
        
        //Now, just return the "result" array :
        return result;
    }
}
